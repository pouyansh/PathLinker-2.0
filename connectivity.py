import networkx as nx
from matplotlib import pyplot as plt
from matplotlib import colors as mcolors

from file_methods import read_source_and_destinations, read_nodes

colors = dict(mcolors.BASE_COLORS, **mcolors.CSS4_COLORS)

datas = ["Alpha6Beta4Integrin", "AndrogenReceptor", "BCR", "BDNF", "CRH", "EGFR1", "FSH", "Hedgehog", "IL1",
         "IL2", "IL3", "IL4", "IL5", "IL6", "IL9", "IL-7", "KitReceptor", "Leptin", "Notch", "Oncostatin_M",
         "Prolactin", "RANKL", "TCR", "TGF_beta_Receptor", "TNFalpha", "TSH", "TSLP", "TWEAK", "Wnt"]

# defining the bounds for which we want to compute the connectivity
bounds = [100 * (i + 1) for i in range(25)]
pallet = [colors['deepskyblue'], colors['silver'], colors['black'], colors['springgreen'], colors['turquoise'],
          colors['deepskyblue'], colors['dodgerblue'], colors['blue']]

methods = ["ours", "rwr", "PathLinker"]
connected_pairs = [[[] for _ in range(len(bounds))] for _ in range(len(methods))]


def compute_connected_pairs(filename, sources, destinations, method, nodes_map):
    # defining a graph for each bound
    G = [nx.DiGraph() for _ in range(len(bounds))]

    # reading the pathway generated by our algorithm
    edges = []
    with open(filename, 'r') as f:
        for line in f:
            sp = line.split()
            if sp[0] != "#tail":
                if method == "PathLinker":
                    edges.append([nodes_map[sp[0]], nodes_map[sp[1]]])
                else:
                    edges.append([int(sp[0]), int(sp[1])])

    connected_pairs_data = [0 for _ in range(len(bounds))]
    for i in range(len(bounds)):
        for j in range(min(bounds[i], len(edges))):
            G[i].add_edge(edges[j][0], edges[j][1])

        for seed in sources:
            if G[i].has_node(seed):
                descendants = nx.algorithms.descendants(G[i], seed)
                for target in destinations:
                    if target in descendants:
                        connected_pairs_data[i] += 1

        connected_pairs_data[i] /= len(sources) * len(destinations)
    return connected_pairs_data


for data in datas:
    print(data)
    pathways = ["results/" + data + "edges-ours.txt", "results/" + data + "edges-rwr.txt",
                "data/PathLinker_output/" + data + "k-2000-ranked-edges.txt"]

    rtf_path = "data/NetPath/" + data + "-nodes.txt"
    nodes = read_nodes("data/nodes_map.txt")
    # reading seeds and targets
    seeds, targets = read_source_and_destinations(rtf_path, nodes)

    for k in range(len(methods)):
        connected_pairs_method = compute_connected_pairs(pathways[k], seeds, targets, methods[k], nodes)

        for i in range(len(bounds)):
            connected_pairs[k][i].append(connected_pairs_method[i])

for k in range(len(methods)):
    plt.plot(bounds, [sum(connected_pairs[k][i]) / len(datas) for i in range(len(bounds))], color=pallet[k],
             label=methods[k])
plt.ylim(bottom=0, top=1)
plt.legend()
plt.title("percentage of Receptors and TFs connected to each other")
plt.savefig("output/connectivity_directed.png")
plt.close()
