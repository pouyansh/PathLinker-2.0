import networkx as nx
from matplotlib import pyplot as plt
from matplotlib import colors as mcolors
from utils import reader

from pathway_files import read_source_and_destinations, read_pathway_names

colors = dict(mcolors.BASE_COLORS, **mcolors.CSS4_COLORS)
pallet = [colors['black'], colors['red'], colors['grey'], colors['lightgray'], colors['brown']]

input_graph = "data/interactome.txt"
graph_type = "directed"
DATABASE = "KEGG"
pathway_names = read_pathway_names(DATABASE, cleaned=True)

# defining the bounds for which we want to compute the connectivity
bounds = [200 * (i + 1) for i in range(10)]
# pallet = [colors['deepskyblue'], colors['silver'], colors['black'], colors['springgreen'], colors['turquoise'],
#           colors['deepskyblue'], colors['dodgerblue'], colors['blue']]

methods = ["PathLinker", "ours", "rwr", "EdgeLinker"]
connected_pairs = [[[] for _ in range(len(bounds))] for _ in range(len(methods))]


def compute_connected_pairs(filename, sources, destinations, method, nodes_map):
    # defining a graph for each bound
    if graph_type == "undirected":
        G = [nx.Graph() for _ in range(len(bounds))]
    else:
        G = [nx.DiGraph() for _ in range(len(bounds))]

    # reading the pathway generated by our algorithm
    edges = []
    with open(filename, 'r') as f:
        for line in f:
            sp = line.split()
            if sp[0] != "#tail":
                if method == "PathLinker":
                    edges.append([nodes_map[sp[0]], nodes_map[sp[1]]])
                else:
                    edges.append([int(float(sp[0])), int(float(sp[1]))])

    connected_pairs_data = [0 for _ in range(len(bounds))]
    for i in range(len(bounds)):
        for j in range(min(bounds[i], len(edges))):
            G[i].add_edge(edges[j][0], edges[j][1])

        for seed in sources:
            if G[i].has_node(seed):
                descendants = nx.algorithms.descendants(G[i], seed)
                for target in destinations:
                    if target in descendants:
                        connected_pairs_data[i] += 1

        connected_pairs_data[i] /= len(sources) * len(destinations)
    return connected_pairs_data


def get_file_name(method, pathway):
    if method == "PathLinker":
        return "data/PathLinker_output/" + pathway + "k-2000-ranked-edges.txt"
    if method == "EdgeLinker":
        return "results/" + pathway + "edges-el.txt"
    return "results/" + pathway + "edges-" + method + ".txt"


_, node_to_id, _, id_to_node, _ = reader.read_graph(input_graph, graph_type)

for pathway_name in pathway_names:
    print(pathway_name)
    pathways = ["results/" + pathway_name + "edges-ours.txt", "results/" + pathway_name + "edges-rwr.txt",
                "data/PathLinker_output/" + pathway_name + "k-2000-ranked-edges.txt"]

    # reading seeds and targets
    seeds, targets = read_source_and_destinations(DATABASE, pathway_name, node_to_id)

    for k in range(len(methods)):
        connected_pairs_method = compute_connected_pairs(get_file_name(methods[k], pathway_name), seeds, targets,
                                                         methods[k], node_to_id)
        print(connected_pairs_method)

        for i in range(len(bounds)):
            connected_pairs[k][i].append(connected_pairs_method[i])

for k in range(len(methods)):
    plt.plot(bounds, [sum(connected_pairs[k][i]) / len(pathway_names) for i in range(len(bounds))], color=pallet[k],
             label=methods[k])
plt.ylim(bottom=0, top=1.1)
plt.legend()
plt.title("Pathway Connectivity - " + graph_type + " edges" + " - " + DATABASE)
plt.savefig("output/connectivity_" + DATABASE + "_" + graph_type + str(bounds[-1]) + ".png")
plt.close()
